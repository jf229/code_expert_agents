#!/usr/bin/env python3
"""
Query Agent - Query pre-analyzed codebase using stored comprehensive analysis.

This agent loads a comprehensive analysis of a codebase (generated by IterateAndSynthesizeAgent)
and answers questions using that full-codebase context.

Usage:
    # Query using comprehensive analysis (default, best quality)
    python query_agent.py /path/to/repo "what does authentication do?"

    # Query using other strategies (if available)
    python query_agent.py /path/to/repo "what does authentication do?" --vector-store
    python query_agent.py /path/to/repo "what does authentication do?" --graph

Use Case: Answer questions with full codebase context (best quality, fast after initial scan).
"""

import argparse
import os
import pickle
import sys
from dotenv import load_dotenv

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from shared import load_config, setup_and_pull_models
from shared.base_agent import BaseAgent
from shared.storage_manager import get_project_file_path
from shared.response_generators import UnifiedResponseGenerator
from langchain.schema import Document


class QueryAgent(BaseAgent):
    """Query agent that uses pre-computed comprehensive analysis."""

    def __init__(self, repo_path: str, storage_type: str = "comprehensive"):
        """
        Initialize QueryAgent.

        Args:
            repo_path: Path to the repository to query
            storage_type: Type of storage to use ("comprehensive", "vector-store", "graph", "multi-rep")
        """
        load_dotenv()
        super().__init__(name="Query Agent")
        self.repo_path = repo_path
        self.storage_type = storage_type
        self.comprehensive_analysis = None
        self._load_analysis()

    def _load_analysis(self) -> None:
        """Load the comprehensive analysis from storage."""
        try:
            file_path = get_project_file_path(self.repo_path, "comprehensive_analysis.pkl")
            if not os.path.exists(file_path):
                raise FileNotFoundError(f"Comprehensive analysis not found at {file_path}")

            with open(file_path, "rb") as f:
                self.comprehensive_analysis = pickle.load(f)
            print(f"Loaded comprehensive analysis for {os.path.basename(self.repo_path)}")
        except Exception as e:
            print(f"Error loading analysis: {e}")
            raise

    def prepare(self, question: str) -> None:
        """No preparation needed - analysis is already loaded."""
        pass

    def retrieve(self, question: str):
        """
        Retrieve documents for the question.

        For comprehensive mode: returns the full analysis as a document
        For other modes: would delegate to other retrieval strategies
        """
        if self.storage_type == "comprehensive":
            # Create a document from the comprehensive analysis
            if not self.comprehensive_analysis:
                return []

            doc = Document(
                page_content=self.comprehensive_analysis,
                metadata={
                    "source": "comprehensive_analysis",
                    "type": "full_codebase_analysis",
                    "repo": os.path.basename(self.repo_path),
                }
            )
            return [doc]

        elif self.storage_type == "vector-store":
            # TODO: Implement vector store retrieval
            print("Vector store retrieval not yet implemented")
            return []

        elif self.storage_type == "graph":
            # TODO: Implement graph-based retrieval
            print("Graph-based retrieval not yet implemented")
            return []

        elif self.storage_type == "multi-rep":
            # TODO: Implement multi-representation retrieval
            print("Multi-representation retrieval not yet implemented")
            return []

        else:
            raise ValueError(f"Unknown storage type: {self.storage_type}")

    def analyze(self, question: str, documents):
        """Analyze question with retrieved documents (uses BaseAgent default)."""
        return super().analyze(question, documents)


def main():
    """Main entry point for Query Agent."""
    parser = argparse.ArgumentParser(
        description="Query a pre-analyzed codebase using comprehensive analysis"
    )
    parser.add_argument("repo", help="Path to the repository to query")
    parser.add_argument("question", help="Question to ask about the codebase")
    parser.add_argument(
        "--storage-type",
        choices=["comprehensive", "vector-store", "graph", "multi-rep"],
        default="comprehensive",
        help="Storage type to use for retrieval (default: comprehensive)",
    )
    args = parser.parse_args()

    # Validate repo path
    if not os.path.isdir(args.repo):
        print(f"Error: Repository path does not exist: {args.repo}")
        return

    # Load configuration
    config = load_config()
    setup_and_pull_models(config)

    # Create and run agent
    try:
        agent = QueryAgent(args.repo, storage_type=args.storage_type)
        result = agent.run(args.question)
        if result:
            print("\nâœ“ Query completed successfully")
    except FileNotFoundError as e:
        print(f"Error: {e}")
        print(f"\nPlease run the analysis first:")
        print(f"  python iterate_and_synthesize.py 'Analyze this project' --repo {args.repo}")


if __name__ == "__main__":
    main()
